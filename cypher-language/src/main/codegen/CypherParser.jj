
options {
    STATIC = false;
    IGNORE_CASE = true;
    UNICODE_INPUT = true;
}

PARSER_BEGIN(CypherParserImpl)

package org.polypheny.db.mql.parser.impl;


import java.io.Reader;
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.Set;import javax.print.DocFlavor.READER;
import org.polypheny.db.Cypher;
import org.polypheny.db.CypherList;import org.polypheny.db.CypherNode;
import org.polypheny.db.CypherOperator;import org.polypheny.db.dml.CypherCreate;
import org.polypheny.db.dql.CypherAs;
import org.polypheny.db.dql.CypherOrderBy;import org.polypheny.db.dql.CypherReturn;
import org.polypheny.db.dql.CypherReturnExpr;
import org.polypheny.db.dql.CypherUnwind;

/**
 * openCypher language (Cypher) parser, generated from Parser.jj by JavaCC.
 *
 * The public wrapper for this parser is {@code CypherParser}.
**/
public class CypherParserImpl extends CypherAbstractParserImpl {

private static Metadata metadata;


      /**
       * ParserFactory implementation for creating parser.
       */
      public static final ParserFactory FACTORY = new ParserFactory() {
          public CypherAbstractParserImpl getParser(Reader reader) {
              final MqlParserImpl parser = new CypherParserImpl(reader);
              if (reader instanceof SourceStringReader) {
                  final String Cypher = ((SourceStringReader) reader).getSourceString();
                  parser.setOriginalMql(cypher);
              }
            return parser;
          }
      };

      public CypherParseException normalizeException(Throwable ex)
      {
          try {
              if (ex instanceof ParseException) {
                  ex = cleanupParseException((ParseException) ex);
              }
              return convertException(ex);
          } catch (ParseException e) {
              throw new AssertionError(e);
          }
      }

      public Metadata getMetadata()
      {
          synchronized (CypherParserImpl.class) {
              if (metadata == null) {
                  metadata = new MetadataImpl(new CypherParserImpl(new java.io.StringReader("")));
              }
              return metadata;
          }
      }

      public CypherNode parseMqlExpressionEof() throws Exception
      {
          return Input();
      }

      public CypherNode parseMqlStmtEof() throws Exception
      {
          return Input();
      }

}

PARSER_END(CypherParserImpl)

<DEFAULT> SKIP : { " "
                 | "\t"
                 | "\n"
                 | "\r"
                 | "\f"
}

TOKEN : /* IDENTIFIERS */
{
< MATCH: "MATCH" >
|
< OPTIONAL: "OPTIONAL" >
|
< MANDATORY: "MANDATORY" >
|
< WITH: "WITH" >
|
< WHERE: "WHERE" >
|
< RETURN: "RETURN" >
|
< SET: "SET" >
|
< SSKIP: "SKIP" >
|
< INDEX: "INDEX" >
|
< SCAN: "SCAN" >
|
< JOIN: "JOIN" >
|
< ON: "ON" >
|
< SEEK: "SEEK" >
|
< GRAPH: "GRAPH" >
|
< LIMIT: "LIMIT" >
|
< ORDERBY: "ORDERBY" >
|
< USE: "USE" >
|
< CREATE: "CREATE" >
|
< DELETE: "DELETE" >
|
< DETACH: "DETACH" >
|
< REMOVE: "REMOVE" >
|
< MERGE: "MERGE" >
|
< CALL: "CALL" >
|
< YIELD: "YIELD" >
|
< UNION: "UNION" >
|
< AND: "AND" >
|
< OR: "OR" >
|
< XOR: "XOR" >
|
< NOT: "NOT" >
|
< ALL: "ALL" >
|
< DESC: "DESC" >
|
< ASC: "ASC" >
|
< AS: "AS" >
|
< STAR: ["*"] >
|
< DISTINCT: "DISTINCT" >
|
< UNWIND: "UNWIND" >
|
< CATALOG: "CATALOG" >
|
< CASE: "CASE" >
|
< WHEN: "WHEN" >
|
< THEN: "THEN" >
|
< ELSE: "ELSE" >
|
< END: "END" >
|
< NULL: "null" >
|
< TRUE: ( <STRUE> | <BTRUE> )>
|
< STRUE: "true">
|
< BTRUE: "TRUE">
|
< FALSE: ( <SFALSE> | <BFALSE> )>
|
< SFALSE: "false">
|
< BFALSE: "FALSE" >
|
< IN: "IN" >
|
< IS_NULL: "IS NULL" >
|
< IS_NOT_NULL: "IS NOT NULL" >
|
< STARTS_WITH: "STARTS WITH" >
|
< ENDS_WITH: "ENDS WITH" >
|
< CONTAINS: "CONTAINS" >
|
< EON: ")" >
|
< SON: "(" >
|
< EOR: "]" >
|
< SOR: "[" >
|
< COMMA: "," >
|
< DOT: "." >
|
< ADD: "+=" >
|
< LTE: "<=" >
|
< LT: "<" >
|
< GTE: ">=" >
|
< GT: ">" >
|
< COUNT: "count(" >
|
< MIN: "min(" >
|
< MAX: "max(" >
|
< SUM: "sum(" >
|
< AVG: "avg(" >
|
< COLLECT: "collect(" >
|
< STD: "stdev(" >
|
< STDP: "stdevp(" >
|
< LENGTH: "length(" >
|
< NODES: "nodes(" >
|
< PERCENTILE_D: "percentile_disc(" >
|
< PERCENTILE_C: "percentile_cont(" >
|
< UNSIGNED_DECIMAL_INTEGER: <DIGIT_NO_ZERO> (<DIGIT>)* (<PART_LETTER>)* >
|
< USING: "USING" >
|
< PERIODIC: "PERIODIC" >
|
< COMMIT: "COMMIT" >
|
< PART_LETTER:
    <DIGIT>
    |
    <BCHARS>
    |
    <UNDERSCORE>
    |
    <SCHARS>
    // MISSING EXTEND HERE
>
|
< #SYMBOL: [".", ",", ":", ";", "!", "$", "\"", "'", "(", ")", " ", "\n", "{", "}", "[", "]","&","\\","/", "=", "<" ,">", "�","^", "~", "´", "@" ] | <MATH> >
|
< #MATH: ["*", "/", "-", "+"] >
|
< IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|
< #LETTER: ["_","a"-"z","A"-"Z","ö", "Ö", "ä", "Ä", "ü", "Ü", "à", "À", "ç","Ç", "á", "Á", "è", "È","í","Í", "î", "Î","ó","Ó","ò", "ô", "Ô", "Ò" , "í", "Í", "ë", "Ë", "â", "Â", "ï", "Ï", "é", "É", "ñ", "Ñ", "ß"] >
|
< #DIGIT: ["0"-"9"] >
|
< #DIGIT_NO_ZERO: ["1"-"9"] >
|
< #BCHARS: ["A"-"Z"] >
|
< #SCHARS: ["a"-"z"] >
|
< SEMICOLON: ";" >
|
< UNDERSCORE: "_" >
}

//////////////////////////////////////
////* copied from Parser.jj end */////
//////////////////////////////////////


/**
 * Converts a ParseException (local to this particular instantiation
 * of the parser) into a CypherParseException (common to all parsers).
 */
JAVACODE CypherParseException convertException(Throwable ex){
    if (ex instanceof CypherParseException) {
        return (CypherParseException) ex;
    }
    ParserPos pos = null;
    int[][] expectedTokenSequences = null;
    String[] tokenImage = null;
    if (ex instanceof ParseException) {
        ParseException pex = (ParseException) ex;
        expectedTokenSequences = pex.expectedTokenSequences;
        tokenImage = pex.tokenImage;
        if (pex.currentToken != null) {
            final Token token = pex.currentToken.next;
            pos = new ParserPos(
                token.beginLine,
                token.beginColumn,
                token.endLine,
                token.endColumn);
        }
    } else if (ex instanceof TokenMgrError) {
        TokenMgrError tme = (TokenMgrError) ex;
        expectedTokenSequences = null;
        tokenImage = null;
        // Example:
        //    Lexical error at line 3, column 24.  Encountered "#" after "a".
        final java.util.regex.Pattern pattern = java.util.regex.Pattern.compile(
            "(?s)Lexical error at line ([0-9]+), column ([0-9]+).*");
        java.util.regex.Matcher matcher = pattern.matcher(ex.getMessage());
        if (matcher.matches()) {
            int line = Integer.parseInt(matcher.group(1));
            int column = Integer.parseInt(matcher.group(2));
            pos = new ParserPos(line, column, line, column);
        }
    } else if (ex instanceof PolyphenyDbContextException) {
        // PolyphenyDbContextException is the standard wrapper for exceptions
        // produced by the validator, but in the parser, the standard is
        // SqlParseException; so, strip it away. In case you were wondering,
        // the PolyphenyDbContextException appears because the parser
        // occasionally calls into validator-style code such as
        // SqlSpecialOperator.reduceExpr.
        PolyphenyDbContextException ece =
            (PolyphenyDbContextException) ex;
        pos = new ParserPos(
            ece.getPosLine(),
            ece.getPosColumn(),
            ece.getEndPosLine(),
            ece.getEndPosColumn());
        ex = ece.getCause();
    }

    return new CypherParseException(
        ex.getMessage(), pos, expectedTokenSequences, tokenImage, ex);
}

/**
 * Removes or transforms misleading information from a parse exception.
 *
 * @param e dirty excn
 *
 * @return clean excn
 */
JAVACODE ParseException cleanupParseException(ParseException ex)
{
    if (ex.expectedTokenSequences == null) {
        return ex;
    }
    int iIdentifier = Arrays.asList(ex.tokenImage).indexOf("<IDENTIFIER>");

    // Find all sequences in the error which contain identifier. For
    // example,
    //       {<IDENTIFIER>}
    //       {A}
    //       {B, C}
    //       {D, <IDENTIFIER>}
    //       {D, A}
    //       {D, B}
    //
    // would yield
    //       {}
    //       {D}
    boolean id = false;
    final List<int[]> prefixList = new ArrayList<int[]>();
    for (int i = 0; i < ex.expectedTokenSequences.length; ++i) {
        int[] seq = ex.expectedTokenSequences[i];
        int j = seq.length - 1;
        int i1 = seq[j];
        if (i1 == iIdentifier) {
            int[] prefix = new int[j];
            System.arraycopy(seq, 0, prefix, 0, j);
            prefixList.add(prefix);
        }
    }

    if (prefixList.isEmpty()) {
        return ex;
    }

    int[][] prefixes = (int[][])
        prefixList.toArray(new int[prefixList.size()][]);

    // Since <IDENTIFIER> was one of the possible productions,
    // we know that the parser will also have included all
    // of the non-reserved keywords (which are treated as
    // identifiers in non-keyword contexts).  So, now we need
    // to clean those out, since they're totally irrelevant.

    final List<int[]> list = new ArrayList<int[]>();
    Metadata metadata = getMetadata();
    for (int i = 0; i < ex.expectedTokenSequences.length; ++i) {
        int [] seq = ex.expectedTokenSequences[i];
        String tokenImage = ex.tokenImage[seq[seq.length - 1]];
        String token = MqlParserUtil.getTokenVal(tokenImage);
        if (token == null  || !metadata.isNonReservedKeyword(token)) {
            list.add(seq);
            continue;
        }
        boolean match = matchesPrefix(seq, prefixes);
        if (!match) {
            list.add(seq);
        }
    }

    ex.expectedTokenSequences =
        (int [][]) list.toArray(new int [list.size()][]);
    return ex;
}

JAVACODE protected ParserPos getPos()
{
    return new ParserPos(
        token.beginLine,
        token.beginColumn,
        token.endLine,
        token.endColumn);
}

JAVACODE boolean matchesPrefix(int[] seq, int[][] prefixes)
{
    nextPrefix:
    for (int[] prefix : prefixes) {
        if (seq.length == prefix.length + 1) {
            for (int k = 0; k < prefix.length; k++) {
                if (prefix[k] != seq[k]) {
                    continue nextPrefix;
                }
            }
            return true;
        }
    }
    return false;
}

JAVACODE CypherNode setInputIfNotNull ( CypherNode parent, CypherNode child ) {
    if( parent != null ){
        parent.setInput(child);
    }else {
        parent = child;
    }
    return parent;
}


//////////////////////////////////////
//////////////////////////////////////
//////////////////////////////////////


/** Root production. */
CypherNode Input() :
{
 CypherNode n;
}
{
    /** only one statement for now **/
    n = Statement() ( <SEMICOLON> n = Statement() )* [<SEMICOLON>] <EOF>
    { return n; }
}


/** Brace matching production. */
CypherNode Statement() :
{
    MqlNode input;
    MqlNode n;
}
{

    n = PeriodicCommitQuery()
    |
    [ n = UseClause() ] input = SingleQueryOrAdministrationCommand()

    { return setInputIfNotNull( n, input ); }
}

CypherNode SingleQueryOrAdministrationCommand() :
{
    CypherNode n;
}
{
    n = CreateAdministrationCommand()
    |
    n = ShowCommand()
    |
    <CATALOG> (
        n = AdministrationCommand()
        |
        n = ShowAdministrationCommandAfterCatalog()
    )
    |
    n = AdministrationCommand()
    |
    n = SingleQuery()  (input = Union())*

    { return setInputIfNotNull( n, input ); }
}


CypherNode PeriodicCommitQuery() :
{
    CypherCSVLoadClause n;
    CypherNode m;
    Token d;
}
{
    <USING> <PERIODIC> <COMMIT> [ d = <UNSIGNED_DECIMAL_INTEGER> ] n = LoadCSVClause() m = PeriodicCommitBody()
    {
        n.setInputIfNotNull( n, m );
        if ( d != null ){
            n.setAmount( Integer.parseInt( d.image ) );
        }
        return n;
    }
}

CypherNode PeriodicCommitBody() :
{
    List<CypherNode> ns = new ArrayList<>();
    CypherNode n;
}
{
    (
      n = Clause()
      { ns.add( n ); }
    )*
    { return new CypherList<>( getPos(), ns ); }

}

CypherNode RegularQuery() :
{
    CypherNode n;
    CypherNode input;
    List<CypherNode> ns = new ArrayList<>();
}
{
    n = SingleQuery() (
        input = Union()
        { ns.add( input ); }
    )*
    { return n.setInput( new CypherList<>( getPos(), ns ) ); }
}

CypherNode Union() :
{
    CypherNode n;
    boolean all = false;
}
{
    <UNION> [ <ALL> { all = true; }] n = SingleQuery()
    { return n; }
}

CypherNode SingleQuery() :
{
    CypherNode n;
    List<CypherNode> ns = new ArrayList<>();
}
{
    (
        n = Clause()
        { ns.add( n ); }
    )+
    { return new CypherList<>( getPos(), ns ); }
}

CypherNode Clause( ):
{
    CypherNode n;
}
{
    n = UseClause()
    |
    n = ReturnClause()
    |
    n = CreateClause()
    |
    n = DeleteClause()
    |
    n = SetClause()
    |
    n = RemoveClause()
    |
    n = MatchClause()
    |
    n = MergeClause()
    |
    n = WithClause()
    |
    n = UnwindClause()
    |
    n = CallClause()
    |
    n = SubQueryClause()
    |
    n = LoadCSVClause()
    |
    n = ForEachClause()

    { return n; }
}

CypherNode UseClause() :
{
    CypherNode n;
    boolean graph = false;
}
{
    <USE> [ <GRAPH> { graph = true; }] n = Expression()
    { return new CypherUseClause( getPos(), n, graph ); }
}

CypherNode ReturnClause() :
{
    CypherNode n;
}
{
    <RETURN> n = ReturnBody()
    { return n; }
}

CypherNode ReturnBody() :
{
    CypherNode n;
    List<CypherNode> returns = new ArrayList<>();
    boolean distinct = false;
    CypherNode order;
    CypherNode skip;
    CypherNode limit;
}
{
    [ <DISTINCT> { distinct = true; }
    ( (<STAR> { n = CypherNode.STAR; }) | n = ReturnItem() { returns.add(n); } )]
    ( <COMMA> n = ReturnItem() { returns.add(n); } )*
    [ order = Order() ]
    [ skip = Skip() ]
    [ limit = Limit() ]
    { return new CypherReturn( getPos(), new CypherList<>( getPost(), returns), distinct, order, skip, limit ); }
}

CypherNode ReturnItem() :
{
    CypherNode n;
    Cyphernode as;
}
{
    n = Expression() [ <AS> as = Variable() ]
    {
        n = setInputIfNotNull( n, as );
        return n;
    }
}

CypherNode Order() :
{
    CypherNode n;
    List<CypherNode> ns = new ArrayList<>();
}
{
    <ORDERBY> n = OrderItem() { ns.add(n); } ( <COMMA> n = OrderItem() { ns.add(n); } )*
    { return new CypherOrderBy( getPos(), new CypherList<>( getPost(), ns)); }
}

CypherNode OrderItem() :
{
    CypherNode n;
    boolean asc = true;
}
{
    n = Expression() [ <ASC> | (<DESC> { asc = false; }) ]
    { return new CypherOrderByItem( getPos(), n, asc ); }
}

CypherNode Skip() :
{
    CypherNode n;
}
{
    <SSKIP> n = Expression()
    { return n; }
}

CypherNode Limit() :
{
    CypherNode n;
}
{
    <LIMIT> n = Expression()
    { return n; }
}

CypherNode WithClause() :
{
    CypherNode n;
    CypherNode where;
}
{
    n = ReturnBody() [ where = Where() ]
    {
        n = setInputIfNotNull( n, where );
        return n;
    }
}

CypherNode CreateClause() :
{
    CypherNode n;
}
{
    <CREATE> n = PatternList()
    { return new CypherCreate( getPos(), n); }
}

CypherNode SetClause() :
{
    CypherNode n;
    List<CypherNode> ns = new ArrayList<>();
}
{
    <SET> n = SetItem()
    { ns.add(n); }
    (<COMMA> n = SetItem() { ns.add(n); })*
    { return new CypherSet( getPos(), new CypherList<>( getPost(), ns) ); }
}

CypherNode SetItem() :
{
    CypherNode n;
    CypherNode val;
    CypherOperator op;
}
{ // maybe error
    n = PropertyExpression() <EQ> val = Expression()
    { return new CypherAssign( getPos(), n,CypherOperator.EQ, val ); }
    |
    n = Variable()
    (
        (
            <EQ>
            { op = CypherOperator.EQ; }
        )
        |
        <ADD>
        { op = CypherOperator.INC; }
    )
    val = Expression()
    { return new CypherAssign( getPos(), n, op, val ); }
    |
    (
        val = NodeLabels()
        { return new CypherAssign( getPos(), n, CypherOperator.AKA, val ); }
    )
}

CypherNode RemoveClause () :
{
    CypherNode n;
    List<CypherNode> ns = new ArrayList<>();
}
{
    <REMOVE> n = RemoveItem()
    { ns.add(n); }
    (
        <COMMA> n = RemoveItem()
        { ns.add(n); }
    )*
    { return new RemoveClause( getPos(), new CypherList<>(ns) ); }
}

CypherNode RemoveItem():
{
    CypherNode n;
    CypherNode m;
}
{
    n = PropertyExpression()
    { return new CypherProperty( getPos(), n); }
    |
    n = Variable() m = NodeLabels()
    { return new CypherAssign( getPos(), n, OperatorName.AKA, m); }
}

CypherNode DeleteClause() :
{
    List<CypherNode> ns = new ArrayList<>();
    CypherNode n;
    boolean detach = false;
}
{
    [ <DETACH> { detach = true; }]
    <DELETE> n = Expression()
    { ns.add(n); }
    (
        n = Expression()
        { ns.add(n); }
    )*
    { return new CypherDelete<>( getPos(), ns, detach ); }
}

CypherNode MatchClause() :
{
    CypherNode n;
    boolean optional = false;
    CypherNode hints;
    Cyphernode where;
}
{
    [ <OPTIONAL> { opional = true; } ]
    <MATCH> n = PatternList() hints = Hints()
    [ where = Where() ]
    { return new CypherMatch( getPos(), n, hints, where ); }
}

CypherNode Hints() :
{
    CypherNode n;
    List<CypherNode> ns = new ArrayList<>();
}
{
    (
        <USING>
        (
            n = Index()
            |
            n = Join()
            |
            n = Scan()
        )
        { ns.add(n); }
    )*
    { return new CypherHints( getPos(), new CypherList<>( getPos(), ns )); }
}

CypherNode Index() :
{
    CypherNode n;
    boolean seek = false;
    CypherNode type;
    CypherNode names;
}
{
    <INDEX> [<SEEK> { seek = true; }]
    n = Variable() type = LabelOrRelType()
    <SON> names = SymbolicNameList1() <EON>
    { return new CypherIndex( getPos(), n, type, names); }
}

CypherNode Join():
{
    CypherNode n;
}
{
    <JOIN> <ON> n = VariableList1()
    { return new CypherJoin( getPos(), n ); }
}

CypherNode Scan():
{
    CypherNode n;
    CypherNode type;
}
{
    <SCAN> n = Variable() type = LabelOrRelType()
    { return new CypherScan( getPos(), n); }
}
